"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CanvasVideoRecorder = exports.createCanvasVideoRecorder = exports.VideoRecorder = exports.createVideoRecorder = exports.VideoRecorderResult = void 0;
if (typeof Z_STANDALONE !== 'undefined' && Z_STANDALONE) {
    if (document.currentScript) {
        const url = new URL(document.currentScript.src);
        let href = url.toString();
        if (url.pathname) {
            let pathParts = href.split("/");
            pathParts.pop();
            href = pathParts.join("/") + "/";
        }
        console.log("Current script: ", href);
        __webpack_public_path__ = (href + __webpack_public_path__);
    }
}
////
const event_1 = require("./event");
const options_1 = require("./options");
let Worker;
if (typeof Z_STANDALONE !== 'undefined' && Z_STANDALONE) {
    Worker = require('worker-loader?filename=viceorecorder.js&inline=fallback!./recorder-worker');
}
else {
    Worker = require('worker-loader?filename=viceorecorder.js!./recorder-worker');
}
if (Worker.default)
    Worker = Worker.default;
class VideoRecorderResult {
    constructor(arrayBuffer) {
        this.arrayBuffer = arrayBuffer;
    }
    get blob() {
        return new Blob([this.arrayBuffer], { type: "video/mp4" });
    }
    asDataURL() {
        return new Promise(resolve => {
            let filereader = new FileReader();
            filereader.addEventListener("loadend", () => resolve(filereader.result));
            filereader.readAsDataURL(this.blob);
        });
    }
}
exports.VideoRecorderResult = VideoRecorderResult;
function createVideoRecorder(width, height, acquireFrame, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield VideoRecorder.create(width, height, acquireFrame, options);
    });
}
exports.createVideoRecorder = createVideoRecorder;
class VideoRecorder {
    constructor(_width, _height, _acquireFrame, _options) {
        this._width = _width;
        this._height = _height;
        this._acquireFrame = _acquireFrame;
        this._options = _options;
        this.onStart = new event_1.Event();
        this.onComplete = new event_1.Event1();
        this._worker = new Worker();
        this._needsFrame = false;
        this._isRunning = false;
        this._lastFrameTime = 0;
        this._loadMessageNumber = 0;
        let wasmModule = require("./videorecorder.wasm");
        this._worker.postMessage({ type: "init", wasm: wasmModule.default || wasmModule });
        this.frameUpdate = this.frameUpdate.bind(this);
        this._audioFrame = this._audioFrame.bind(this);
        this._worker.addEventListener("message", (msg) => {
            if (msg.data && msg.data.type === "nextframe") {
                this._needsFrame = true;
                return;
            }
            if (msg.data && msg.data.type === "finish") {
                this.result = new VideoRecorderResult(msg.data.arr);
                this.onComplete.emit(this.result);
            }
        });
    }
    static create(width, height, acquireFrame, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let ret = new VideoRecorder(width, height, acquireFrame, options_1.getResolvedOptions(options || {}));
            yield ret.loaded();
            return ret;
        });
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.stop();
            this._isRunning = true;
            let audioSampleRate;
            if (this._options.audio) {
                this._audioContext = this._options.audioContext;
                if (!this._audioContext) {
                    let context = window.AudioContext || window.webkitAudioContext;
                    this._audioContext = new context({
                        sampleRate: this._options.audioSampleRate
                    });
                }
                if (this._options.audioSourceNode) {
                    this._source = this._options.audioSourceNode;
                }
                else {
                    let stream = this._options.audioMediaStream;
                    if (!stream)
                        stream = yield navigator.mediaDevices.getUserMedia({ audio: true });
                    this._source = this._audioContext.createMediaStreamSource(stream);
                }
                this._processor = this._audioContext.createScriptProcessor(1024, 1, 1);
                this._processor.connect(this._audioContext.destination);
                audioSampleRate = this._audioContext.sampleRate;
                this._source.connect(this._processor);
                this._processor.onaudioprocess = this._audioFrame;
            }
            this._needsFrame = true;
            delete this.result;
            this._lastFrameTime = this._getTime();
            this._worker.postMessage({
                type: "start",
                maxFrameRate: this._options.maxFrameRate,
                width: this._width,
                height: this._height,
                speed: this._options.speed,
                targetBitrateKBPS: this._options.targetBitrateKBPS,
                quality: this._options.quality,
                audioSampleRate: audioSampleRate
            });
            if (this._options.autoFrameUpdate)
                requestAnimationFrame(this.frameUpdate);
            this.onStart.emit();
        });
    }
    stop() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._isRunning)
                return;
            this._isRunning = false;
            this._worker.postMessage({
                type: "stop"
            });
            if (this._processor) {
                (_a = this._source) === null || _a === void 0 ? void 0 : _a.disconnect(this._processor);
                this._processor.onaudioprocess = null;
                this._processor.disconnect();
            }
            if (!this._options.audioContext) {
                yield ((_b = this._audioContext) === null || _b === void 0 ? void 0 : _b.close());
            }
            this._audioContext = undefined;
        });
    }
    _getTime() {
        if (this._audioContext)
            return this._audioContext.currentTime * 1000.0;
        return performance.now();
    }
    _audioFrame(e) {
        if (!this._isRunning)
            return;
        this._worker.postMessage({
            type: "aud",
            dat: e.inputBuffer.getChannelData(0).buffer,
            duration: e.inputBuffer.duration * 1000
        });
    }
    frameUpdate() {
        let frameTime = this._getTime();
        if (!this._needsFrame || !this._isRunning || frameTime < this._lastFrameTime + (1 / this._options.maxFrameRate)) {
            if (this._options.autoFrameUpdate)
                requestAnimationFrame(this.frameUpdate);
            return;
        }
        let data = this._acquireFrame();
        this._worker.postMessage({
            type: "frame",
            dat: data,
            duration: frameTime - this._lastFrameTime
        }, [data]);
        this._lastFrameTime = frameTime;
        this._needsFrame = false;
        if (this._options.autoFrameUpdate)
            requestAnimationFrame(this.frameUpdate);
    }
    loaded() {
        let token = this._loadMessageNumber++;
        return new Promise(resolve => {
            let handler = (msg) => {
                if (msg.data && msg.data.type === "loaded" && msg.data.token === token) {
                    this._worker.removeEventListener("message", handler);
                    resolve();
                }
            };
            this._worker.addEventListener("message", handler);
            this._worker.postMessage({
                type: "load",
                token: token
            });
        });
    }
}
exports.VideoRecorder = VideoRecorder;
function createCanvasVideoRecorder(canvas, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield CanvasVideoRecorder._createCanvasVideoRecorder(canvas, options);
    });
}
exports.createCanvasVideoRecorder = createCanvasVideoRecorder;
class CanvasVideoRecorder extends VideoRecorder {
    constructor(canvas, opts) {
        let width = canvas.width;
        let height = canvas.height;
        if (opts.halfSample) {
            width >>= 1;
            height >>= 1;
        }
        width -= width % 2;
        height -= height % 2;
        super(width, height, () => this._getData(), opts);
        this._canvas = canvas;
        this._offscreenCanvas = document.createElement("canvas");
        this._offscreenCanvas.width = width;
        this._offscreenCanvas.height = height;
        let context = this._offscreenCanvas.getContext("2d");
        if (!context)
            throw new Error("Unable to get context for offscreen buffer");
        this._offscreenContext = context;
    }
    static _createCanvasVideoRecorder(canvas, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let ret = new CanvasVideoRecorder(canvas, options_1.getResolvedOptions(options || {}));
            yield ret.loaded();
            return ret;
        });
    }
    _getData() {
        this._offscreenContext.drawImage(this._canvas, 0, 0, this._offscreenCanvas.width, this._offscreenCanvas.height);
        let data = this._offscreenContext.getImageData(0, 0, this._offscreenCanvas.width, this._offscreenCanvas.height);
        return data.data.buffer;
    }
}
exports.CanvasVideoRecorder = CanvasVideoRecorder;
let worker = new Worker();
